#!/usr/bin/env python

import sys
import subprocess
import os
import atexit
import resource
import getopt
import signal
import datetime
import select
import fcntl

from time import sleep
from tempfile import mkdtemp
from collections import deque

debug = False
timeout=0
slce = True
old_slicer = False
require_slicer = False
arch = None
prp = None
klee_params = None
pta = None
repeat_slicing = 1
no_symexe = False
optimize=None
runexec=False

running_processes = []

class Timeout(Exception):
    pass

def start_timeout(sec):
    def alarm_handler(signum, data):
        raise Timeout

    signal.signal(signal.SIGALRM, alarm_handler)
    signal.alarm(sec)

def stop_timeout():
    # turn of timeout
    signal.signal(signal.SIGALRM, signal.SIG_DFL)
    signal.alarm(0)

def run_symbiotic(symbiotic_location, benchmark, outputfile):
    if runexec:
        cmd = ['runexec', '--no-container']
        if timeout != 0:
            cmd += ['--softtimelimit={0}'.format(timeout),
                    '--timelimit={0}'.format(timeout + 3)]
        cmd += ['--output={0}'.format(outputfile), '--']
    else:
        cmd = []

    cmd += ['{0}/symbiotic'.format(symbiotic_location)]
    if debug:
        cmd.append('--debug=all')

    if not prp is None:
       cmd.append('--prp={0}'.format(os.path.expanduser(prp)))

    if not slce:
        cmd.append('--no-slice')

    if arch == '64bit':
        cmd.append('--64')

    if timeout != 0:
        cmd.append('--timeout={0}'.format(timeout))

    if old_slicer:
        cmd.append('--old-slicer')

    if require_slicer:
        cmd.append('--require-slicer')

    if no_symexe:
        cmd.append('--no-symexe')

    optimize='before-O3,after-O3'
    if optimize:
        cmd.append('--optimize={0}'.format(optimize))

    # we run on sv-comp benchmarks where we assume that
    # malloc never fails
    cmd.append('--malloc-never-fails')

    if not pta is None:
        cmd.append('--pta')
        cmd.append(pta)

    benchabs = os.path.abspath(benchmark)
    witnessfile = '--witness={0}/{1}.graphml'.format(os.path.dirname(benchabs),
                                                     os.path.basename(benchmark))

    cmd.append(witnessfile)
    cmd.append(benchmark)

    if not runexec:
        outfl = open(outputfile, 'w')
    else:
        outfl = subprocess.PIPE

    p = subprocess.Popen(cmd, stdout=outfl, stderr=subprocess.STDOUT)
    global running_processes
    running_processes.append(p)

    return p

def verify_error_path_cpa(benchmark, outfile, prpfile, symbiotic_dir):
    benchabs = os.path.abspath(benchmark)
    witness = '{0}.graphml'.format(benchabs)
    prpfile = os.path.abspath(os.path.expanduser(prpfile))
    if runexec:
        cmd = ['runexec', '--no-container']
        if timeout != 0:
            cmd += ['--softtimelimit={0}'.format(90),
                    '--timelimit={0}'.format(93)]
        cmd += ['--output={0}'.format(outfile), '--']
    else:
        cmd = []
   #cmd += ['scripts/cpa.sh',
   #        '-noout', '-heap', '10000M', '-predicateAnalysis',
   #        '-setprop', 'cfa.useMultiEdges=false',
   #        '-setprop', 'cpa.predicate.solver=MATHSAT5',
   #        '-setprop', 'cfa.simplifyCfa=false',
   #        '-setprop', 'cfa.allowBranchSwapping=false',
   #        '-setprop', 'cpa.predicate.ignoreIrrelevantVariables=false',
   #        '-setprop', 'counterexample.export.assumptions.assumeLinearArithmetics=true',
   #        '-setprop', 'coverage.enabled=false',
   #        '-setprop', 'coverage.mode=TRANSFER',
   #        '-setprop', 'coverage.export=true',
   #        '-setprop', 'analysis.traversal.byAutomatonVariable=__DISTANCE_TO_VIOLATION',
   #        '-setprop', 'cpa.automaton.treatErrorsAsTargets=false',
   #        '-setprop', 'WitnessAutomaton.cpa.automaton.treatErrorsAsTargets=true',
   #        '-setprop', 'parser.transformTokensToLines=false',
   #        '-setprop', 'spec.matchOriginLine=true',
   #        '-setprop', 'spec.matchOffset=true',
   #        '-setprop', 'spec.matchAssumeCase=true',
   #        '-setprop', 'spec.matchSourcecodeData=false',
   #        '-setprop', 'spec.strictMatching=false',
   #        '-setprop', 'cpa.composite.inCPAEnabledAnalysis=true',
   #        '-setprop', 'cpa.predicate.handlePointerAliasing=false',
   #        '-skipRecursion']

   #if arch == '64bit':
   #    cmd.append('-64')

   #if timeout > 0:
   #    cmd += ['-timelimit', '{0}'.format(timeout)]

   #cmd += ['-spec', witness, '-spec', os.path.abspath(prpfile), benchabs]
    cmd += ['scripts/cpa.sh', '-config', 'config/witness-validation.properties',
            '-disable-java-assertions', '-heap', '10000m',
            '-setprop', 'cpa.arg.errorPath.graphml=violation-witness.graphml',
            '-spec', witness, '-timelimit', '90s',
            '-spec', prpfile, benchabs]

    if not runexec:
        outf = open(outfile, 'w')
    else:
        outf = subprocess.PIPE
    p = subprocess.Popen(cmd, shell=False, cwd='{0}/CPAchecker'.format(symbiotic_dir),
                         stderr=subprocess.STDOUT, stdout=outf)
    global running_processes
    running_processes.append(p)

    return p

def set_ulimit():
    resource.setrlimit(resource.RLIMIT_CPU, (90, 90))

def verify_error_path_ultimate(benchmark, outfile, prpfile, symbiotic_dir):
    benchabs = os.path.abspath(benchmark)
    witness = '{0}.graphml'.format(benchabs)
    prpfile = os.path.abspath(os.path.expanduser(prpfile))
    if runexec:
        cmd = ['runexec', '--no-container']
        if timeout != 0:
            cmd += ['--softtimelimit={0}'.format(90),
                    '--timelimit={0}'.format(93)]
        cmd += ['--output={0}'.format(outfile), '--']
    else:
        cmd = []

   #cmd += ['python3', 'UltimateWitnessChecker.py',
   #        os.path.abspath(prpfile), benchabs]

   #if arch != '64bit':
   #    cmd.append('32bit')

   #cmd += ['simple', os.path.abspath(witness)]

    cmd += ['python3', 'Ultimate.py', prpfile, '--validate', witness]
    if arch != '64bit':
        cmd.append('32bit')
    else:
        cmd.append('64bit')
    cmd.append(benchabs)

    if not runexec:
        outf = open(outfile, 'w')
    else:
        outf = subprocess.PIPE
    p = subprocess.Popen(cmd, shell=False, cwd='{0}/UltimateAutomizer'.format(symbiotic_dir),
                         stderr=subprocess.STDOUT, stdout=outf,
                         preexec_fn = set_ulimit) # ultimate does not seem to have it own timeout
    global running_processes
    running_processes.append(p)

    return p

def print_file(filename, first = 100, last = 100):
    'Return the first few lines and last few lines of a file'

    with open(filename) as f:
        counter = 0
        tail = deque(maxlen=last)
        for line in iter(f.readlines()):
            if counter < first:
                sys.stdout.write(line)
            else:
                tail.append(line)
            counter += 1

        cnt = counter - first - last
        if cnt >= 0:
            if cnt > 0:
                print(' ... {0} lines ...'.format(cnt))
            for line in tail:
                sys.stdout.write(line)

def print_witness(benchmark):
    benchabs = os.path.abspath(benchmark)
    pth = '{0}/{1}.graphml'.format(os.path.dirname(benchabs),
                                   os.path.basename(benchmark))

    print_file(pth)

#def poll_add_fd(poll, fd):
#    poll.register(fd, select.POLLIN | select.POLLERR | select.POLLHUP)

def cpa_confirmed(output):
    with open(output) as f:
        for l in iter(f.readlines()):
            if 'Verification result: FALSE' in l:
                return True

    return False


def ultimate_confirmed(output):
    with open(output) as f:
        for l in iter(f.readlines()):
            if l.strip() == 'FALSE':
                return True

    return False

def verify_error_path(benchmark, prpfile, symbiotic_dir):
    # run both checker paralelly
    cpa_outputfile = '{0}.cpa.output'.format(benchmark)
    ultimate_outputfile = '{0}.ultimate.output'.format(benchmark)

    cpa = verify_error_path_cpa(benchmark, cpa_outputfile,
                                prpfile, symbiotic_dir)
    ultimate = verify_error_path_ultimate(benchmark, ultimate_outputfile,
                                          prpfile, symbiotic_dir)


    print('=== WITNESS')
    start_timeout(100)
    cpa_result = ''
    ultimate_result = ''
    got = 0
    confirmed = False
    global running_processes
    try:
        processes = [(cpa, cpa_confirmed, cpa_outputfile),
                     (ultimate, ultimate_confirmed, ultimate_outputfile)]
        while processes and not confirmed:
            for p, check, out in processes:
                retval = p.poll()
                if not retval is None:
                    if retval == 0:
                        if check(out):
                            confirmed = True
                    running_processes.remove(p)
                    processes.remove((p,check,out))
                    break
            sleep(1)

        stop_timeout()

        if (confirmed):
            print('confirmed')
        else:
            print('unconfirmed')

        print('=== WITNESS OUTPUT')
        print('--- witness ---')
        print_witness(benchmark)
        print('\n--- witness end ---')
        print('--- CPAchecker output ---')
        print_file(cpa_outputfile, 10, 50)
        print('--- UltimateAutomizer output ---')
        print_file(ultimate_outputfile, 10, 50)
    except Timeout:
        print('timeout')
    finally:
        stop_timeout()
        if cpa.poll() is None:
            cpa.terminate()
            cpa.kill()
            running_processes.remove(cpa)
        if ultimate.poll() is None:
            ultimate.terminate()
            ultimate.kill()
            running_processes.remove(ultimate)

        sys.stdout.flush()

def printTimeConsumed():
    sys.stdout.flush()
    us = resource.getrusage(resource.RUSAGE_CHILDREN)
    usr = getattr(us, 'ru_utime')
    syst = getattr(us, 'ru_stime')

    print('=== TIME CONSUMED')
    print(usr + syst)
    sys.stdout.flush()


def printMemoryUsage():
    sys.stdout.flush()
    us = resource.getrusage(resource.RUSAGE_CHILDREN)
    maxrss = getattr(us, 'ru_maxrss')

    print('=== MEMORY USAGE')
    print(maxrss / 1024.0)
    sys.stdout.flush()

def printVersions(symbiotic_dir, bench_dir):
    version = ''

    cmd = ['./symbiotic', '--version-short']
    p = subprocess.Popen(cmd, shell=False, cwd='{0}'.format(os.path.abspath(symbiotic_dir)),
                         stderr=subprocess.STDOUT, stdout=subprocess.PIPE)
    out, err = p.communicate()
    assert err is None
    # set the symbiotic version
    version = out.strip()

    cmd = ['git', 'rev-parse', '--short=8', 'HEAD']
    p = subprocess.Popen(cmd, shell=False, cwd='{0}'.format(os.path.abspath(bench_dir)),
                         stderr=subprocess.STDOUT, stdout=subprocess.PIPE)


    out, err = p.communicate()
    assert err is None
    # get versions of benchmarks
    version += '-benchmarks:{0}'.format(out.strip())

    print('=== VERSIONS')
    print(version)
    sys.stdout.flush()

def parse_args():
    try:
        opts, args = getopt.getopt(sys.argv[1:], '', ['timeout=',
                                                      'debug', 'no-slice',
                                                      '64', 'prp=', 'cat=', 'old-slicer',
                                                      'require-slicer', 'klee-params=',
                                                      'pta=', 'repeat-slicing=',
                                                      'no-symexe', 'optimize=',
                                                      'no-runexec'])
    except getopt.GetoptError as e:
        print('{0}'.format(str(e)))
        sys.exit(1)

    global prp
    for opt, arg in opts:
        if opt == '--debug':
            global debug
            debug = True
        elif opt == '--timeout':
            global timeout
            timeout = int(arg)
        elif opt == '--no-slice':
            global slce
            slce = False
        elif opt == '--require-slicer':
            global require_slicer
            require_slicer = False
        elif opt == '--64':
            global arch
            arch = '64bit'
        elif opt == '--old-slicer':
            global old_slicer
            old_slicer = True
        elif opt == '--no-symexe':
            global no_symexe
            no_symexe = True
        elif opt == '--prp':
            prp = arg
        elif opt == '--cat':
            benchmark = args[1]
            bench_dir = benchmark[:benchmark.find('/c/')]
            if 'Reach' in arg:
                prp = os.path.expanduser(bench_dir + "/c/PropertyUnreachCall.prp")
            elif 'Overflow' in arg:
                prp = os.path.expanduser(bench_dir + "/c/PropertyOverflow.prp")
            elif 'MemSafety' in arg:
                prp = os.path.expanduser(bench_dir + "/c/PropertyMemSafety.prp")
            elif 'Termination' in arg:
                prp = os.path.expanduser(bench_dir + "/c/PropertyTermination.prp")
            elif 'DefBehavior' in arg:
                prp = os.path.expanduser(bench_dir + "/c/PropertyDefBehavior.prp")
            else:
                prp='UNKNOWN_PROPERTY'
        elif opt == '--pta':
            global pta
            pta = arg
        elif opt == '--optimize':
            global optimize
            optimize = arg
        elif opt == '--repeat-slicing':
            global repeat_slicing
            repeat_slicing = int(arg)
        elif opt == '--klee-params':
            print('NOT IMPLEMENTED')
            sys.exit(1)
            global klee_params
            klee_params = arg
        elif opt == '--no-runexec':
            global runexec
            runexec = False

    return args

def say_result(res):
    print(res)
    return res

def say_time(msg):
    print('{0} at {1}'.format(msg, datetime.datetime.strftime(datetime.datetime.now(), '%Y-%m-%d %H:%M:%S')))
    sys.stdout.flush()

def get_prp(prp):
    if prp is None:
        return []

    # if property is given in file, read the file
    epath = os.path.expanduser(prp)
    if os.path.isfile(epath):
        prp_list = []
        f = open(epath, 'r')
        for line in f.readlines():
            line = line.strip()
            # ignore empty lines
            if line:
                prp_list.append(line)
        f.close()
        return prp_list

    # it is not a file, so it is given as a string
    # FIXME: this does not work for properties given
    # as LTL (there are spaces)
    return prp.split()

def sigpipe_handler(signum, data):
    global running_processes
    for p in running_processes:
        p.kill(2) # SIGINT
        p.terminate()
        p.kill()

if __name__ == "__main__":
    signal.signal(signal.SIGPIPE, sigpipe_handler)
    signal.signal(signal.SIGINT, sigpipe_handler)

    say_time('Starting')

    # kill the processes for sure after some time
    # (klee sometimes ignores signals)
    if timeout:
        subprocess.call(['ulimit', '-t', 3 * timeout])

    pths = parse_args()

    os.chdir('/tmp')

    if len(pths) == 2:
        symbiotic_dir = pths[0]
        benchmark = pths[1]
    else:
        print('=== RESULT')
        print('ERROR')
        print('Usage: run_benchmark [--timeout=n] [--debug] [--no-slice]'
              '[--prp=property_file] [--64] [--klee-params=p] symbiotic_dir benchmark')
        sys.exit(1)

    printVersions(symbiotic_dir, os.path.dirname(benchmark))

    src = os.path.abspath(benchmark)

    #if prp is None:
    #    prp = '{0}/ALL.prp'.format(os.path.dirname(src))

    print('=== RESULT')
    sys.stdout.flush()

    outputfile = '{0}.output'.format(src)
    p = run_symbiotic(symbiotic_dir, src, outputfile)

    p.communicate()
    running_processes.remove(p)
    result = None

    if p.returncode != 0:
	print('Symbiotic returned with {0}'.format(p.returncode))
        result = say_result('ERROR')
    else:
        outf = open(outputfile, 'r')
        if no_symexe:
            for l in iter(outf.readlines()):
                if 'Did not find slicing criterion' in l:
                    result = say_result('TRUE')
                    break
                elif 'UNKNOWN' in l:
                    result = say_result('UNKNOWN')
                elif 'TIMEOUT' in l:
                    result = say_result('TIMEOUT')

            if result is None:
                result = say_result('ERROR')
        else:
            results = ['FALSE', 'TRUE', 'UNKNOWN', 'ERROR', 'TIMEOUT']
            for line in iter(outf.readlines()):
                for r in results:
		    if line.startswith(r):
                        result = say_result(r)
            if result is None:
                result = say_result('ERROR')

    print('=== OUTPUT')
    print_file(outputfile)
    sys.stdout.flush()

    say_time('Starting verifier')
    if result.startswith('FALSE'):
        is_reach = 'CHECK( init(main()), LTL(G ! call(__VERIFIER_error())) )' in get_prp(prp)
        if is_reach:
            verify_error_path(src, prp, symbiotic_dir)
    elif result is None:
        say_result('ERROR')

    printTimeConsumed()
    printMemoryUsage()
    say_time('Total end')

