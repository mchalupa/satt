#!/usr/bin/env python

import sys
import subprocess
import os
import atexit
import resource
import getopt
import signal
import datetime
import select
import fcntl

from time import sleep
from tempfile import mkdtemp
from collections import deque

debug = False
timeout=0
slce = True
old_slicer = False
require_slicer = False
arch = None
prp = None
klee_params = None
pta = None
repeat_slicing = 1
no_symexe = False
optimize=None
runexec=True

class Timeout(Exception):
    pass

def start_timeout(sec):
    def alarm_handler(signum, data):
        raise Timeout

    signal.signal(signal.SIGALRM, alarm_handler)
    signal.alarm(sec)

def stop_timeout():
    # turn of timeout
    signal.signal(signal.SIGALRM, signal.SIG_DFL)
    signal.alarm(0)

def run_symbiotic(symbiotic_location, benchmark, outputfile):
    if runexec:
        cmd = ['runexec', '--no-container']
        if timeout != 0:
            cmd.append('--softtimelimit={0}'.format(timeout),
                       '--timelimit={0}'.format(timeout + 3))
        cmd += ['--output={0}'.format(outputfile), '--']
    else:
        cmd = []

    cmd += ['{0}/symbiotic'.format(symbiotic_location)]
    if debug:
        cmd.append('--debug=all')

    if not prp is None:
       cmd.append('--prp={0}'.format(os.path.expanduser(prp)))

    if not slce:
        cmd.append('--no-slice')

    if arch == '64bit':
        cmd.append('--64')

    if timeout != 0:
        cmd.append('--timeout={0}'.format(timeout))

    if old_slicer:
        cmd.append('--old-slicer')

    if require_slicer:
        cmd.append('--require-slicer')

    if no_symexe:
        cmd.append('--no-symexe')

    optimize='before-O3,after-O3'
    if optimize:
        cmd.append('--optimize={0}'.format(optimize))

    # we run on sv-comp benchmarks where we assume that
    # malloc never fails
    cmd.append('--malloc-never-fails')

    if not pta is None:
        cmd.append('--pta')
        cmd.append(pta)

    benchabs = os.path.abspath(benchmark)
    witnessfile = '--witness={0}/{1}.graphml'.format(os.path.dirname(benchabs),
                                                     os.path.basename(benchmark))

    cmd.append(witnessfile)
    cmd.append(benchmark)

    if not runexec:
        outfl = open(outputfile, 'w')
    else:
        outfl = subprocess.PIPE

    p = subprocess.Popen(cmd, stdout=outfl, stderr=subprocess.STDOUT)
    return p

def verify_error_path_cpa(benchmark, outfile, prpfile, symbiotic_dir):
    benchabs = os.path.abspath(benchmark)
    witness = '{0}.graphml'.format(benchabs)
    if runexec:
        cmd = ['runexec', '--no-container']
        if timeout != 0:
            cmd.append('--softtimelimit={0}'.format(90),
                       '--timelimit={0}'.format(93))
        cmd += ['--output={0}'.format(outfile), '--']
    else:
        cmd = []
    cmd += ['scripts/cpa.sh',
            '-noout', '-heap', '10000M', '-predicateAnalysis',
            '-setprop', 'cfa.useMultiEdges=false',
            '-setprop', 'cpa.predicate.solver=MATHSAT5',
            '-setprop', 'cfa.simplifyCfa=false',
            '-setprop', 'cfa.allowBranchSwapping=false',
            '-setprop', 'cpa.predicate.ignoreIrrelevantVariables=false',
            '-setprop', 'counterexample.export.assumptions.assumeLinearArithmetics=true',
            '-setprop', 'coverage.enabled=false',
            '-setprop', 'coverage.mode=TRANSFER',
            '-setprop', 'coverage.export=true',
            '-setprop', 'analysis.traversal.byAutomatonVariable=__DISTANCE_TO_VIOLATION',
            '-setprop', 'cpa.automaton.treatErrorsAsTargets=false',
            '-setprop', 'WitnessAutomaton.cpa.automaton.treatErrorsAsTargets=true',
            '-setprop', 'parser.transformTokensToLines=false',
            '-setprop', 'spec.matchOriginLine=true',
            '-setprop', 'spec.matchOffset=true',
            '-setprop', 'spec.matchAssumeCase=true',
            '-setprop', 'spec.matchSourcecodeData=false',
            '-setprop', 'spec.strictMatching=false',
            '-setprop', 'cpa.composite.inCPAEnabledAnalysis=true',
            '-setprop', 'cpa.predicate.handlePointerAliasing=false',
            '-skipRecursion']

    if arch == '64bit':
        cmd.append('-64')

    if timeout > 0:
        cmd += ['-timelimit', '{0}'.format(timeout)]

    cmd += ['-spec', witness, '-spec', os.path.abspath(prpfile), benchabs]

    if not runexec:
        outf = open(outfile, 'w')
    else:
        outf = subprocess.PIPE
    p = subprocess.Popen(cmd, shell=False, cwd='{0}/CPAchecker'.format(symbiotic_dir),
                         stderr=subprocess.STDOUT, stdout=outf)

    return p

def verify_error_path_ultimate(benchmark, outfile, prpfile, symbiotic_dir):
    benchabs = os.path.abspath(benchmark)
    witness = '{0}.graphml'.format(benchabs)
    if runexec:
        cmd = ['runexec', '--no-container']
        if timeout != 0:
            cmd.append('--softtimelimit={0}'.format(90),
                       '--timelimit={0}'.format(93))
        cmd += ['--output={0}'.format(outfile), '--']
    else:
        cmd = []

    cmd += ['python3', 'UltimateWitnessChecker.py',
            os.path.abspath(prpfile), benchabs]

    if arch != '64bit':
        cmd.append('32bit')

    cmd += ['simple', os.path.abspath(witness)]

    if not runexec:
        outf = open(outfile, 'w')
    else:
        outf = subprocess.PIPE
    p = subprocess.Popen(cmd, shell=False, cwd='{0}/UltimateAutomizer'.format(symbiotic_dir),
                         stderr=subprocess.STDOUT, stdout=outf)

    return p

def print_file(filename, first = 100, last = 100):
    'Return the first few lines and last few lines of a file'

    with open(filename) as f:
        counter = 0
        tail = deque(maxlen=last)
        for line in iter(f.readlines()):
            if counter < first:
                sys.stdout.write(line)
            else:
                tail.append(line)
            counter += 1

        cnt = counter - first - last
        if cnt >= 0:
            if cnt > 0:
                print(' ... {0} lines ...'.format(cnt))
            for line in tail:
                sys.stdout.write(line)

def print_witness(benchmark):
    benchabs = os.path.abspath(benchmark)
    pth = '{0}/{1}.graphml'.format(os.path.dirname(benchabs),
                                   os.path.basename(benchmark))

    print_file(pth)

#def poll_add_fd(poll, fd):
#    poll.register(fd, select.POLLIN | select.POLLERR | select.POLLHUP)

def cpa_confirmed(output):
    with open(output) as f:
        for l in iter(f.readlines()):
            if 'Verification result: FALSE' in l:
                return True

    return False


def ultimate_confirmed(output):
    with open(output) as f:
        for l in iter(f.readlines()):
            if l.strip() == 'FALSE':
                return True

    return False

def verify_error_path(benchmark, prpfile, symbiotic_dir):
    # run both checker paralelly
    cpa_outputfile = '{0}.cpa.output'.format(benchmark)
    ultimate_outputfile = '{0}.ultimate.output'.format(benchmark)

    cpa = verify_error_path_cpa(benchmark, cpa_outputfile,
                                prpfile, symbiotic_dir)
    ultimate = verify_error_path_ultimate(benchmark, ultimate_outputfile,
                                          prpfile, symbiotic_dir)

    print('=== WITNESS')
    start_timeout(100)
    cpa_result = ''
    ultimate_result = ''
    got = 0
    confirmed = False
    try:
        processes = [(cpa, cpa_confirmed, cpa_outputfile),
                     (ultimate, ultimate_confirmed, ultimate_outputfile)]
        while processes and not confirmed:
            for p, check, out in processes:
                retval = p.poll()
                if not retval is None:
                    if retval == 0:
                        if check(out):
                            confirmed = True
                    processes.remove((p,check,out))
                    break
            sleep(1)

        stop_timeout()

        if (confirmed):
            print('confirmed')
        else:
            print('unconfirmed')

        print('=== WITNESS OUTPUT')
        print('--- witness ---')
        print_witness(benchmark)
        print('--- CPAchecker output ---')
        print_file(cpa_outputfile)
        print('--- UltimateAutomizer output ---')
        print_file(ultimate_outputfile)
    except Timeout:
        print('timeout')
    finally:
        stop_timeout()
        if cpa.poll() is None:
            cpa.terminate()
            cpa.kill()
        if ultimate.poll() is None:
            ultimate.terminate()
            ultimate.kill()

        sys.stdout.flush()

def printTimeConsumed():
    sys.stdout.flush()
    us = resource.getrusage(resource.RUSAGE_CHILDREN)
    usr = getattr(us, 'ru_utime')
    syst = getattr(us, 'ru_stime')

    print('=== TIME CONSUMED')
    print(usr + syst)
    sys.stdout.flush()


def printMemoryUsage():
    sys.stdout.flush()
    us = resource.getrusage(resource.RUSAGE_CHILDREN)
    maxrss = getattr(us, 'ru_maxrss')

    print('=== MEMORY USAGE')
    print(maxrss / 1024.0)
    sys.stdout.flush()

def printVersions(symbiotic_dir):
    version = ''

    f = open(os.path.join(symbiotic_dir, 'SYMBIOTIC_VERSION'), 'r')
    version += 'symb:{0}'.format(f.readline().strip())
    f.close()

    f = open(os.path.join(symbiotic_dir, 'LLVM_NEW_SLICER_VERSION'), 'r')
    version += '-slicer:{0}'.format(f.readline().strip())
    f.close()

    f = open(os.path.join(symbiotic_dir, 'SVC_SCRIPTS_VERSION'), 'r')
    version += '-scripts:{0}'.format(f.readline().strip())
    f.close()

    f = open(os.path.join(symbiotic_dir, 'KLEE_VERSION'), 'r')
    version += '-klee:{0}'.format(f.readline().strip())
    f.close()

    f = open(os.path.join(symbiotic_dir, 'MINISAT_VERSION'), 'r')
    version += '-minisat:{0}'.format(f.readline().strip())
    f.close()

    f = open(os.path.join(symbiotic_dir, 'STP_VERSION'), 'r')
    version += '-stp:{0}'.format(f.readline().strip())
    f.close()

    print('=== VERSIONS')
    print(version)
    sys.stdout.flush()

def parse_args():
    try:
        opts, args = getopt.getopt(sys.argv[1:], '', ['timeout=',
                                                      'debug', 'no-slice',
                                                      '64', 'prp=', 'old-slicer',
                                                      'require-slicer', 'klee-params=',
                                                      'pta=', 'repeat-slicing=',
                                                      'no-symexe', 'optimize=',
                                                      'no-runexec'])
    except getopt.GetoptError as e:
        print('{0}'.format(str(e)))
        sys.exit(1)

    for opt, arg in opts:
        if opt == '--debug':
            global debug
            debug = True
        elif opt == '--timeout':
            global timeout
            timeout = int(arg)
        elif opt == '--no-slice':
            global slce
            slce = False
        elif opt == '--require-slicer':
            global require_slicer
            require_slicer = False
        elif opt == '--64':
            global arch
            arch = '64bit'
        elif opt == '--old-slicer':
            global old_slicer
            old_slicer = True
        elif opt == '--no-symexe':
            global no_symexe
            no_symexe = True
        elif opt == '--prp':
            global prp
            prp = arg
        elif opt == '--pta':
            global pta
            pta = arg
        elif opt == '--optimize':
            global optimize
            optimize = arg
        elif opt == '--repeat-slicing':
            global repeat_slicing
            repeat_slicing = int(arg)
        elif opt == '--klee-params':
            print('NOT IMPLEMENTED')
            sys.exit(1)
            global klee_params
            klee_params = arg
        elif opt == '--no-runexec':
            global runexec
            runexec = False

    return args

def say_result(res):
    print(res)
    return res

def say_time(msg):
    print('{0} at {1}'.format(msg, datetime.datetime.strftime(datetime.datetime.now(), '%Y-%m-%d %H:%M:%S')))
    sys.stdout.flush()

def get_prp(prp):
    # if property is given in file, read the file
    epath = os.path.expanduser(prp)
    if os.path.isfile(epath):
        prp_list = []
        f = open(epath, 'r')
        for line in f.readlines():
            line = line.strip()
            # ignore empty lines
            if line:
                prp_list.append(line)
        f.close()
        return prp_list

    # it is not a file, so it is given as a string
    # FIXME: this does not work for properties given
    # as LTL (there are spaces)
    return prp.split()

if __name__ == "__main__":
    say_time('Starting')
    pths = parse_args()

    if len(pths) == 2:
        symbiotic_dir = pths[0]
        benchmark = pths[1]
    else:
        print('=== RESULT')
        print('ERROR')
        print('Usage: run_benchmark [--timeout=n] [--debug] [--no-slice]'
              '[--prp=property_file] [--64] [--klee-params=p] symbiotic_dir benchmark')
        sys.exit(1)

    printVersions(symbiotic_dir)

    src = os.path.abspath(benchmark)

    if prp is None:
        prp = '{0}/ALL.prp'.format(os.path.dirname(src))

    print('=== RESULT')
    sys.stdout.flush()

    outputfile = '{0}.output'.format(src)
    p = run_symbiotic(symbiotic_dir, src, outputfile)
    p.communicate()

    result = None

    if p.returncode != 0:
        result = say_result('ERROR')
    else:
        outf = open(outputfile, 'r')
        if no_symexe:
            for l in iter(outf.readlines()):
                if 'Did not find slicing criterion' in l:
                    result = say_result('TRUE')
                    break
                elif 'UNKNOWN' in l:
                    result = say_result('UNKNOWN')
                elif 'TIMEOUT' in l:
                    result = say_result('TIMEOUT')

            if result is None:
                result = say_result('ERROR')
        else:
            results = ['FALSE', 'TRUE', 'UNKNOWN', 'ERROR', 'TIMEOUT']
            for line in iter(outf.readlines()):
                start = line[:7].strip()
                if start in results:
                    result = say_result(start)
            if result is None:
                result = say_result('ERROR')

    print('=== OUTPUT')
    print_file(outputfile)
    sys.stdout.flush()

    #say_time('Starting verifier')
    if result == 'FALSE':
        is_reach = 'CHECK( init(main()), LTL(G ! call(__VERIFIER_error())) )' in get_prp(prp)
        if is_reach:
            verify_error_path(src, prp, symbiotic_dir)
    elif result is None:
        say_result('ERROR')

    printTimeConsumed()
    printMemoryUsage()
    say_time('Total end')

