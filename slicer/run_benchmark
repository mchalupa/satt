#!/usr/bin/env python

import sys
import subprocess
import signal
import os
import atexit
import resource
import getopt

from time import sleep
from tempfile import mkdtemp

class Timeout(Exception):
    pass

def start_timeout(sec):
    def alarm_handler(signum, data):
        raise Timeout

    signal.signal(signal.SIGALRM, alarm_handler)
    signal.alarm(sec)

def stop_timeout():
    # turn of timeout
    signal.signal(signal.SIGALRM, signal.SIG_DFL)
    signal.alarm(0)

def set_environ(slicer_location):
    def env_prepend(env, what):
        if os.environ.has_key(env):
            s = '{0}:{1}'.format(what, os.environ[env])
        else:
            s = what

        os.environ[env] = s

    env_prepend('LD_LIBRARY_PATH', '{0}/lib'.format(slicer_location))
    # FIXME
    env_prepend('PATH', '/home-local/statica/build-slicer/llvm-3.6/build/bin')

def run_slicer(slicer_location, benchmark, _debug = False):
    b = '{0}.bc'.format(benchmark)

    # compile benchmark
    cmd = ['clang'.format(slicer_location)]
    cmd.append('-c')
    cmd.append('-emit-llvm')
    cmd.append(benchmark)
    cmd.append('-o')
    cmd.append(b)

    p = subprocess.Popen(cmd)
    p.wait()
    if p.returncode != 0:
        print('ERROR')
        sys.exit(1)

    cmd = ['{0}/bin/llvm-slicer'.format(slicer_location)]
    cmd.append('-c')
    cmd.append('__VERIFIER_error')
    cmd.append(b)

    p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    return p

def printTimeConsumed():
    us = resource.getrusage(resource.RUSAGE_CHILDREN)
    usr = getattr(us, 'ru_utime')
    syst = getattr(us, 'ru_stime')

    print('=== TIME CONSUMED')
    print(usr + syst)
    sys.stdout.flush()


def printMemoryUsage():
    us = resource.getrusage(resource.RUSAGE_CHILDREN)
    maxrss = getattr(us, 'ru_maxrss')

    print('=== MEMORY USAGE')
    print(maxrss / 1024.0)
    sys.stdout.flush()

def printVersions(slicer_dir):
    cmd = ['{0}/bin/llvm-slicer'.format(slicer_dir)]
    cmd.append('-version')

    print('=== VERSIONS')

    p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    out, err = p.communicate()
    print(err)

    sys.stdout.flush()

def parse_args():
    try:
        opts, args = getopt.getopt(sys.argv[1:], '', ['timeout=', 'debug'])
    except getopt.GetoptError as e:
        print('{0}'.format(str(e)))
        sys.exit(1)

    debug = False
    timeout=0

    for opt, arg in opts:
        if opt == '--debug':
            debug = True
        elif opt == '--timeout':
            timeout = int(arg)

    return (args, timeout, debug)

def rmrf_tmp_dir(d):
    return os.system('rm -rf {0}'.format(d))

def copy_source_to_tmp(src):
    # create temporary directory and copy sources there
    tmpdir = mkdtemp(prefix='slicer.', dir='.')
    basename = os.path.basename(src)

    if os.system('cp {0} {1}/{2}'.format(src, tmpdir, basename)) != 0:
        # cp already gave error message
        rmrf_tmp_dir(tmpdir)
        print('=== RESULT')
        print('ERROR')
        sys.exit(1)

    return (tmpdir, '{0}/{1}'.format(tmpdir, basename))

if __name__ == "__main__":

    pths, timeout, debug = parse_args()
    if len(pths) == 2:
        slicer_dir = pths[0]
        benchmark = pths[1]
    else:
        print('=== RESULT')
        print('ERROR')
        print('Usage: run_benchmark [--timeout=n] [--debug] slicer_dir benchmark')
        sys.exit(1)

    tmpdir, src = copy_source_to_tmp(benchmark)

    set_environ(slicer_dir)

    printVersions(slicer_dir)
    print('=== RESULT')
    sys.stdout.flush()

    start_timeout(timeout)

    try:
        p = run_slicer(slicer_dir, src, debug)
        (out, err) = p.communicate()
        stop_timeout()

        if p.returncode != 0:
            print('ERROR')

        if not err is None:
            print(err)
            if 'saving sliced module' in err:
                print('UNKNOWN')
            else:
                print('ERROR')
        else:
            print('ERROR')

        if not out is None:
            print(out)

        sys.stdout.flush()
    except Timeout:
        print('TIMEOUT')
        sys.stdout.flush()
    finally:
        stop_timeout()

        printTimeConsumed()
        printMemoryUsage()

        notdone = rmrf_tmp_dir(tmpdir)
