#!/usr/bin/env python
#
#  -- Symbiotic tool --
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
#  MA 02110-1301, USA.

import sys
import os
import re
import getopt
import resource
from tempfile import mkdtemp
from subprocess import call, Popen, STDOUT, PIPE

usage_msg = """
Usage: run_slicer [--64 | --timeout=t | --version | --old-slicer] symbiotic source
    --64              Use 64-bit environment
    --timeout=t       Set timeout to t seconds
    --old-slicer      Run old slicer
    --no-optimize     Pass --no-optimize flag to symbiotic
    --no-prepare      Pass --no-prepare flag to symbiotic
    --version         Return version
"""

VERSION='master.2'

def parse_command_line():
    try:
        opts, args = getopt.getopt(sys.argv[1:], '',
                                   ['64', 'timeout=', 'old-slicer',
                                    'no-optimize', 'no-prepare'])
    except getopt.GetoptError as e:
        sys.stderr.write('{0}'.format(str(e)))
        sys.exit(1)

    old_slicer = False
    timeout=0
    bit64 = False
    no_optimize = False
    no_prepare = False

    for opt, arg in opts:
        if opt == '--old-slicer':
            old_slicer = True
        elif opt == '--no-optimize':
            no_optimize = True
        elif opt == '--no-preapre':
            no_prepare = True
        elif opt == '--64':
            bit64 = True
        elif opt == '--timeout':
            timeout = arg

    return (bit64, old_slicer, no_optimize, no_prepare, timeout, args)

def printTimeConsumed():
    us = resource.getrusage(resource.RUSAGE_CHILDREN)
    usr = getattr(us, 'ru_utime')
    syst = getattr(us, 'ru_stime')

    print('=== TIME CONSUMED')
    print(usr + syst)
    sys.stdout.flush()


def printMemoryUsage():
    us = resource.getrusage(resource.RUSAGE_CHILDREN)
    maxrss = getattr(us, 'ru_maxrss')

    print('=== MEMORY USAGE')
    print(maxrss / 1024.0)
    sys.stdout.flush()

#def print_statistics(symbiotic):
#   dr = os.path.dirname(symbiotic)
#   llvm_link = os.path.abspath('{0}/bin/llvm-link'.format(dr))
#   opt = os.path.abspath('{0}/bin/opt'.format(dr))
#
#   cmd = [opt, '--strip-debug', '-strip-dead-prototypes',
#          '-strip', '-o', '/dev/null', '-print-module', 'code.bc']
#   proc = Popen(cmd, stdout=PIPE, stderr=STDOUT)
#   out, err = proc.communicate()
#   assert err is None
#
#   if proc.returncode != 0:
#       sys.stderr.write('Failed getting statistics')
#       print('ERROR')
#       sys.exit(0)
#
#   # comment or metadata
#   r1 = re.compile('^\s*[;!].*')
#   # attribute
#   r2 = re.compile('^\s*attributes #.*')
#
#   for line in iter(out.splitlines()):
#       line = line.lstrip()
#       if line == '' or line[0] == ';' or line[0] == '!' or line.startswith('attributes #'):
#           continue
#
#       print(line)

def rmrf_tmp_dir(d):
    return os.system('rm -rf {0}'.format(d))

def copy_source_to_tmp(src):
    # create temporary directory and copy sources there
    tmpdir = mkdtemp(prefix='slicer.', dir='.')
    basename = os.path.basename(src)

    if os.system('cp {0} {1}/{2}'.format(src, tmpdir, basename)) != 0:
        # cp already gave error message
        rmrf_tmp_dir(tmpdir)
        print('=== RESULT')
        print('ERROR')
        sys.exit(1)

    return (tmpdir, basename)

if __name__ == "__main__":
    bit64, old_slicer, no_optimize, no_prepare, timeout, args = parse_command_line()
    if len(args) != 2:
        sys.stderr.write(usage_msg)
        sys.exit(1)

    symbiotic = args[0]
    source = args[1]

    print('=== VERSIONS')
    print(VERSION)

    tmpdir, src = copy_source_to_tmp(source)
    os.chdir(tmpdir)

    print('=== RESULT ')

    # run the slicer
    cmd = [symbiotic, '--debug=slicer', '--no-symexe', '--output=code.bc']
    if bit64:
        cmd.append('--64')
    if timeout != 0:
        cmd.append('--timeout={0}'.format(timeout))
    if old_slicer:
        cmd.append('--old-slicer')

    if no_optimize:
        cmd.append('--no-optimize')
    #if no_prepare:
    #cmd.append('--no-prepare')

    cmd.append(src)

    proc = Popen(cmd, stdout=PIPE, stderr=STDOUT)
    out, err = proc.communicate()
    assert err is None

    if proc.returncode != 0:
        print('ERROR')
        print(out)
        sys.exit(0)

    if old_slicer:
        # old slicer does not return 'Sliced away'
        # it succeeds when it does not crash
        result = 'UNKNOWN'
    else:
        result = 'ERROR'

    # parse output (even with old slicer - it can return timeout)
    for line in iter(out.splitlines()):
        line = line.strip()
        if line == 'TIMEOUT':
            result = 'TIMEOUT'
        elif 'Sliced away' in line:
            print(line)
        elif 'saving sliced module' in line:
            result = 'UNKNOWN' # all ok
        elif 'Did not find slicing criterion' in line:
            result = 'UNKNOWN' # in this case it sliced too
            print(line)

    print result
    # on error print whole output, so that we know what happend
    if result == 'ERROR':
        print(out)

    #print_statistics(symbiotic)
    printTimeConsumed()
    printMemoryUsage()

    sys.stderr.flush()
    sys.stdout.flush()

    rmrf_tmp_dir(tmpdir)

    sys.exit(0)
